/* List of updates:
************** WEEK 1 *********************
Kim - dayOfWeek [1,7] & time [1,24] constraints
************** WEEK 2 *********************
Kim - began implementing schedule manager class 

To Do: 
1. Constraint - a person should not be able to input overlapping times 
	(i.e. on a Monday, a person cannot input a time from 1-5 and another time from 3-7 (3-5 are "overlapping: times))
2. Constraint - create a method to handle when user inputs a string for int variable (variables include: time, day of week, yes or no, etc)
3. Schedule Manager - editPerson & createSchedule methods
4. Change variables to Const (Days of week)
*/

// Project.cpp : Defines the entry point for the console application.
//

#include <iostream>
#include <string>
#include <vector

using namespace std;

class Time
{
private:
	int startHour;
	int endHour;
	int timeOccurance = 0;

public:

	//Hours should be in military time
	Time(int startHour, int endHour)
	{
		this->startHour = startHour;
		this->endHour = endHour;
	}
	void incrimentTimeOccurance()
	{
		timeOccurance++;
	}
	int getTimeOccurance()
	{
		return timeOccurance;
	}
	int getStartHour()
	{
		return startHour;
	}

	int getEndHour()
	{
		return endHour;
	}

};

class Day
{
private:
	//Person p;
	int priority;
	std::vector<Time*> today;

public:

	//Insert Time object based on startHour and endHour
	void insertTime(int startHour, int endHour)
	{
		if (endHour - startHour != 1)
		{
			for (int i = startHour; i < endHour; i++)
			{
				Time* t = new Time(i, i + 1);
				today.push_back(t);
			}
		}
		else
		{
			Time* t = new Time(startHour, endHour);
			today.push_back(t);
		}
	
	}
	//Function is used for determining the ultimateSchedule
	void insertTimeUltimateSchedule(int startHour, int endHour)
	{
		bool equalsTime = false;
		if (today.size() == 0)
		{
			Time* t = new Time(startHour, endHour);
			today.push_back(t);
		}
		else
		{
			for (int i = 0; i < today.size(); i++)
			{
				if (today.at(i)->getStartHour() == startHour)
				{
					today.at(i)->incrimentTimeOccurance();
					equalsTime = true;
				}
			}
			if (!equalsTime)
			{
				Time* t = new Time(startHour, endHour);
				today.push_back(t);
			}
		}
	}
	void deleteTime(int startHour, int endHour)
	{
		int n = -1; // Stores index value of time object

		for (unsigned int i = 0; i < today.size(); i++)
		{
			int iStartHour = today.at(i)->getStartHour();
			int iEndHour = today.at(i)->getEndHour();

			if ((startHour == iStartHour) && (endHour == iEndHour))
			{
				n = i;
			}
		}
		if (n != -1)
		{
			today.erase(today.begin() + n);
		}
		else
		{
			std::cout << "Start Hour: " << startHour << "End Hour: " << endHour << "could not be deleted \n\n";
		}
	}
	
	std::vector<Time*> getTime()
	{
		return today;
	}
};

class Person
{
private:
	std::string firstName;
	std::string lastName;
	//Holds all the days and times for each week for a single person. Essentially, this is a person’s individual “schedule.”
	//Days are 1-7, starting from Sunday and ending with Saturday
	Day week[7];

public:
	Person(std::string firstName, std::string lastName)
	{
		this->firstName = firstName;
		this->lastName = lastName;

		//tentative menu
		std::cout << "Insert a time? (0=No, 1=Yes): ";
		int N; std::cin >> N;

		while (N == 1)
		{
			std::cout << "Day of Week: ";
			int dayOfWeek; std::cin >> dayOfWeek;
			while(dayOfWeek<1 || dayOfWeek>7) {
				std::cout<< "Invalid day, please input again";
				std::cin >> dayOfWeek;
			}
				
			std::cout << "Start time: ";
			int startTime; std::cin >> startTime;
			while(startTime<0 || startTime>24) {
				std::cout<<"Invalid start time, please input again";
				std::cin >> startTime;
			}
			std::cout << "End time: ";
			int endTime; std::cin >> endTime;
			while(endTime<0 || endTime>24 || endTime!=startTime) {
				std::cout<<"Invalid end time, please input again";
				std::cin >> endTime;
			}
			
			insertTime(dayOfWeek, startTime, endTime);
			std::cout << "Insert a time? (0=No, 1=Yes): ";
			std::cin >> N;
		}
	}

	/*need to add constraints:
	-a person should not be able to input overlapping times (i.e. on a Monday, a person cannot input a time from 1-5 and another time from 3-7 (3-5 are "overlapping: times))
	*/
	void insertTime(int dayOfWeek, int startHour, int endHour)
	{
		week[dayOfWeek - 1].insertTime(startHour, endHour);
	}

	//Calls deleteTime method in Day field
	void deleteTime(int dayOfWeek, int startHour, int endHour)
	{

	}

	std::vector<Time*> getDay(int dayOfWeek)
	{
		return week[dayOfWeek].getTime();
	}
	//removed returnName as its the same as getName(), getName can be renamed if you want it to be returnName instead.
	Day* returnWeek()
	{
		return week; 
	}

	std::string getName()
	{
		return firstName + " " + lastName;
	}
};

void outputSchedule(std::vector<Person*> group)
{
	for (int i = 0; i < 7; i++)
	{
		std::cout << "\n\nOn day " << i;
		for (int j = 0; j < group.size(); j++)
		{
			std::cout << "\n\n " << group.at(j)->getName() << " schedule is: ";
			for (int k = 0; k < group.at(j)->getDay(i).size(); k++)
				std::cout << group.at(j)->getDay(i).at(k)->getStartHour() << "-" << group.at(j)->getDay(i).at(k)->getEndHour() << " , ";
		}
	}
}

//Determines the best possible time for the group to meet (determines the day and times with the most overlapping time occurances)
void ultimateSchedule(std::vector<Person*> group)
{
	Day groupWeek[7];
	int timeOccurance = 0;

	//goes through every day of the week
	for (int i = 0; i < 7; i++)
	{
		//goes through every group member
		for (int j = 0; j < group.size(); j++)
		{
			//goes through every time
			for (int k = 0; k < group.at(j)->getDay(i).size(); k++)
			{
				groupWeek[i].insertTimeUltimateSchedule(group.at(j)->getDay(i).at(k)->getStartHour(), group.at(j)->getDay(i).at(k)->getEndHour());
			}
		}
	}

	//sets timeOccurance with the greatest value of times that overlap
	for (int i = 0; i < 7; i++)
	{
		for (int k = 0; k < groupWeek[i].getTime().size(); k++)
		{
			if (groupWeek[i].getTime().at(k)->getTimeOccurance() > timeOccurance)
				timeOccurance = groupWeek[i].getTime().at(k)->getTimeOccurance();
		}
	}

	//outputs the best time to meet
	std::cout << "The best time for the group to meet is:\n\n";
	for (int i = 0; i < 7; i++)
	{
		for (int k = 0; k < groupWeek[i].getTime().size(); k++)
		{
			if(timeOccurance == groupWeek[i].getTime().at(k)->getTimeOccurance())
				std::cout << timeOccurance + 1 << " member's schedules match on day " << i << " at times " << groupWeek[i].getTime().at(k)->getStartHour() << " - " << groupWeek[i].getTime().at(k)->getEndHour() << "\n\n";
		}
	}

}

int main()
{
	std::vector<Person*> group;
	std::string firstName;
	std::string lastName;
	int input = 1;

	while (input != 0)
	{
		std::cout << "Enter:\n'1' to create a new team member.\n'2' to print member names.\n'3' to delete a member.\n'4' to print schedule.\n'5' to print best time to meet.\n'0' to end.\n\n";
		std::cin >> input;
		switch (input)
		{
		case 1:
		{
			std::cout << "Enter your first (press enter) and last name (press enter):\n\n";
			std::cin >> firstName;
			std::cin >> lastName;
			Person* p = new Person(firstName, lastName);
			group.push_back(p);
		}
		break;
		case 2:
		{
			for (int i = 0; i < group.size(); i++)
				std::cout << group.at(i)->getName() << "\n";
		}
		break;
		case 3:
		{
			//*************** + DELETE PERSON FROM GROUP  *******************
			std::cout << "To delete, enter the first (press enter) and last name (press enter): \n\n";
			std::cin >> firstName;
			std::cin >> lastName;
			std::string name = firstName + " " + lastName;

			int n = -1; // Stores index value of person in group

			for (unsigned int i = 0; i < group.size(); i++)
			{
				std::string pName = group.at(i)->getName();
				if (pName == name)
				{
					n = i;
				}
			}
			if (n != -1)
			{
				group.erase(group.begin() + n);
			}
			else
			{
				std::cout << name << "does not exist!\n\n";
			}
			//**************************************************************
		}
		break;
		case 4:
		{
			outputSchedule(group);
		}
		break;
		case 5:
		{
			ultimateSchedule(group);
		}
		break;
		default:
			cout << "Invalid menu input << endl;
			break;
		}
	}

	return 0;
}

